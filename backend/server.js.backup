import express from 'express';
import cors from 'cors';
import { initDB, getDB, saveDB } from './database.js';
import { generateRoundRobinMatches, generateEliminationMatches, generateMixedMatches } from './matchGenerator.js';

const app = express();
const PORT = 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Initialize database
await initDB();

// API Routes

// GET all tournaments
app.get('/api/tournaments', (req, res) => {
  try {
    const db = getDB();
    const result = db.exec('SELECT * FROM tournaments ORDER BY datum DESC');
    
    if (result.length === 0) {
      return res.json([]);
    }

    const columns = result[0].columns;
    const values = result[0].values;
    
    const tournaments = values.map(row => {
      const tournament = {};
      columns.forEach((col, index) => {
        tournament[col] = row[index];
      });
      return tournament;
    });

    res.json(tournaments);
  } catch (error) {
    console.error('Error fetching tournaments:', error);
    res.status(500).json({ error: 'Chyba pÅ™i naÄÃ­tÃ¡nÃ­ turnajÅ¯' });
  }
});

// GET single tournament by ID
app.get('/api/tournaments/:id', (req, res) => {
  try {
    const db = getDB();
    const result = db.exec('SELECT * FROM tournaments WHERE id = ?', [parseInt(req.params.id)]);
    
    if (result.length === 0 || result[0].values.length === 0) {
      return res.status(404).json({ error: 'Turnaj nenalezen' });
    }

    const columns = result[0].columns;
    const values = result[0].values[0];
    
    const tournament = {};
    columns.forEach((col, index) => {
      tournament[col] = values[index];
    });

    res.json(tournament);
  } catch (error) {
    console.error('Error fetching tournament:', error);
    res.status(500).json({ error: 'Chyba pÅ™i naÄÃ­tÃ¡nÃ­ turnaje' });
  }
});

// POST create new tournament
app.post('/api/tournaments', (req, res) => {
  try {
    const { nazev, typ, maxPocetHracu, datum, misto, popis } = req.body;

    // Validation
    if (!nazev || !typ || !maxPocetHracu || !datum || !misto) {
      return res.status(400).json({ error: 'ChybÃ­ povinnÃ¡ pole' });
    }

    const db = getDB();
    
    db.run(`
      INSERT INTO tournaments (nazev, typ, maxPocetHracu, datum, misto, popis)
      VALUES (?, ?, ?, ?, ?, ?)
    `, [nazev, typ, parseInt(maxPocetHracu), datum, misto, popis || '']);

    saveDB();

    // Get the last inserted tournament
    const result = db.exec('SELECT * FROM tournaments ORDER BY id DESC LIMIT 1');
    
    if (result.length > 0) {
      const columns = result[0].columns;
      const values = result[0].values[0];
      
      const newTournament = {};
      columns.forEach((col, index) => {
        newTournament[col] = values[index];
      });
      
      res.status(201).json(newTournament);
    } else {
      res.status(500).json({ error: 'Chyba pÅ™i vytvÃ¡Å™enÃ­ turnaje' });
    }
  } catch (error) {
    console.error('Error creating tournament:', error);
    res.status(500).json({ error: 'Chyba pÅ™i vytvÃ¡Å™enÃ­ turnaje' });
  }
});

// PUT update tournament
app.put('/api/tournaments/:id', (req, res) => {
  try {
    const { nazev, typ, maxPocetHracu, datum, misto, popis, status } = req.body;
    const db = getDB();
    
    db.run(`
      UPDATE tournaments 
      SET nazev = ?, typ = ?, maxPocetHracu = ?, datum = ?, misto = ?, popis = ?, status = ?
      WHERE id = ?
    `, [nazev, typ, parseInt(maxPocetHracu), datum, misto, popis || '', status || 'nadchazejici', parseInt(req.params.id)]);

    saveDB();

    // Get updated tournament
    const result = db.exec('SELECT * FROM tournaments WHERE id = ?', [parseInt(req.params.id)]);
    
    if (result.length === 0 || result[0].values.length === 0) {
      return res.status(404).json({ error: 'Turnaj nenalezen' });
    }

    const columns = result[0].columns;
    const values = result[0].values[0];
    
    const updatedTournament = {};
    columns.forEach((col, index) => {
      updatedTournament[col] = values[index];
    });

    res.json(updatedTournament);
  } catch (error) {
    console.error('Error updating tournament:', error);
    res.status(500).json({ error: 'Chyba pÅ™i aktualizaci turnaje' });
  }
});

// DELETE tournament
app.delete('/api/tournaments/:id', (req, res) => {
  try {
    const db = getDB();
    db.run('DELETE FROM tournaments WHERE id = ?', [parseInt(req.params.id)]);
    saveDB();
    
    res.json({ message: 'Turnaj byl ÃºspÄ›Å¡nÄ› smazÃ¡n' });
  } catch (error) {
    console.error('Error deleting tournament:', error);
    res.status(500).json({ error: 'Chyba pÅ™i mazÃ¡nÃ­ turnaje' });
  }
});

// ============ PLAYER ENDPOINTS ============

// GET all players for a tournament
app.get('/api/tournaments/:id/players', (req, res) => {
  try {
    const db = getDB();
    const result = db.exec('SELECT * FROM players WHERE tournament_id = ? ORDER BY jmeno ASC', [parseInt(req.params.id)]);
    
    if (result.length === 0) {
      return res.json([]);
    }

    const columns = result[0].columns;
    const values = result[0].values;
    
    const players = values.map(row => {
      const player = {};
      columns.forEach((col, index) => {
        player[col] = row[index];
      });
      return player;
    });

    res.json(players);
  } catch (error) {
    console.error('Error fetching players:', error);
    res.status(500).json({ error: 'Chyba pÅ™i naÄÃ­tÃ¡nÃ­ hrÃ¡ÄÅ¯' });
  }
});

// POST add new player to tournament
app.post('/api/tournaments/:id/players', (req, res) => {
  try {
    const { jmeno } = req.body;
    const tournament_id = parseInt(req.params.id);

    // Validation
    if (!jmeno || jmeno.trim() === '') {
      return res.status(400).json({ error: 'JmÃ©no hrÃ¡Äe je povinnÃ©' });
    }

    const db = getDB();

    // Check tournament exists
    const tournamentResult = db.exec('SELECT maxPocetHracu FROM tournaments WHERE id = ?', [tournament_id]);
    if (tournamentResult.length === 0 || tournamentResult[0].values.length === 0) {
      return res.status(404).json({ error: 'Turnaj nebyl nalezen' });
    }

    const maxPocetHracu = tournamentResult[0].values[0][0];

    // Check player count limit
    const playerCountResult = db.exec('SELECT COUNT(*) FROM players WHERE tournament_id = ?', [tournament_id]);
    const playerCount = playerCountResult[0].values[0][0];

    if (playerCount >= maxPocetHracu) {
      return res.status(400).json({ error: `MaximÃ¡lnÃ­ poÄet hrÃ¡ÄÅ¯ (${maxPocetHracu}) byl dosaÅ¾en` });
    }

    db.run(`
      INSERT INTO players (tournament_id, jmeno)
      VALUES (?, ?)
    `, [tournament_id, jmeno.trim()]);

    saveDB();

    // Get the newly created player
    const result = db.exec('SELECT * FROM players ORDER BY id DESC LIMIT 1');
    
    if (result.length > 0) {
      const columns = result[0].columns;
      const values = result[0].values[0];
      
      const newPlayer = {};
      columns.forEach((col, index) => {
        newPlayer[col] = values[index];
      });
      
      res.status(201).json(newPlayer);
    } else {
      res.status(500).json({ error: 'Chyba pÅ™i vytvÃ¡Å™enÃ­ hrÃ¡Äe' });
    }
  } catch (error) {
    console.error('Error creating player:', error);
    res.status(500).json({ error: 'Chyba pÅ™i pÅ™idÃ¡vÃ¡nÃ­ hrÃ¡Äe' });
  }
});

// DELETE player from tournament
app.delete('/api/players/:id', (req, res) => {
  try {
    const db = getDB();
    db.run('DELETE FROM players WHERE id = ?', [parseInt(req.params.id)]);
    saveDB();
    
    res.json({ message: 'HrÃ¡Ä byl ÃºspÄ›Å¡nÄ› smazÃ¡n' });
  } catch (error) {
    console.error('Error deleting player:', error);
    res.status(500).json({ error: 'Chyba pÅ™i mazÃ¡nÃ­ hrÃ¡Äe' });
  }
});

// POST start tournament - generate matches
app.post('/api/tournaments/:id/start', (req, res) => {
  try {
    const db = getDB();
    const tournament_id = parseInt(req.params.id);

    // Check if tournament exists
    const tournamentResult = db.exec('SELECT * FROM tournaments WHERE id = ?', [tournament_id]);
    if (tournamentResult.length === 0) {
      return res.status(404).json({ error: 'Turnaj nebyl nalezen' });
    }

    const tournament = {};
    tournamentResult[0].columns.forEach((col, index) => {
      tournament[col] = tournamentResult[0].values[0][index];
    });

    // Check if tournament is already started
    if (tournament.status !== 'nadchazejici') {
      return res.status(400).json({ error: 'Turnaj jiÅ¾ byl zahÃ¡jen' });
    }

    // Get players for tournament
    const playersResult = db.exec('SELECT * FROM players WHERE tournament_id = ? ORDER BY jmeno', [tournament_id]);
    
    if (playersResult.length === 0 || playersResult[0].values.length === 0) {
      return res.status(400).json({ error: 'Turnaj musÃ­ mÃ­t alespoÅˆ 2 hrÃ¡Äe' });
    }

    const players = playersResult[0].values.map(row => {
      const player = {};
      playersResult[0].columns.forEach((col, index) => {
        player[col] = row[index];
      });
      return player;
    });

    if (players.length < 2) {
      return res.status(400).json({ error: 'Turnaj musÃ­ mÃ­t alespoÅˆ 2 hrÃ¡Äe' });
    }

    // Generate matches based on tournament type
    let matches = [];
    switch (tournament.typ) {
      case 'skupina':
        matches = generateRoundRobinMatches(players);
        break;
      case 'pavouk':
        matches = generateEliminationMatches(players);
        break;
      case 'smiseny':
        matches = generateMixedMatches(players);
        break;
      default:
        return res.status(400).json({ error: 'NeznÃ¡mÃ½ typ turnaje' });
    }

    // Insert matches into database
    matches.forEach(match => {
      db.run(`
        INSERT INTO matches (tournament_id, round, match_number, player1_id, player2_id, status)
        VALUES (?, ?, ?, ?, ?, ?)
      `, [tournament_id, match.round, match.match_number, match.player1_id, match.player2_id, match.status]);
    });

    // Update tournament status to 'probiha'
    db.run('UPDATE tournaments SET status = ? WHERE id = ?', ['probiha', tournament_id]);
    
    saveDB();

    res.json({ 
      message: 'Turnaj byl ÃºspÄ›Å¡nÄ› zahÃ¡jen',
      matchesGenerated: matches.length
    });
  } catch (error) {
    console.error('Error starting tournament:', error);
    res.status(500).json({ error: 'Chyba pÅ™i zahÃ¡jenÃ­ turnaje' });
  }
});

// GET matches for tournament
app.get('/api/tournaments/:id/matches', (req, res) => {
  try {
    const db = getDB();
    const tournament_id = parseInt(req.params.id);

    const result = db.exec(`
      SELECT 
        m.*,
        p1.jmeno as player1_name,
        p2.jmeno as player2_name,
        w.jmeno as winner_name
      FROM matches m
      LEFT JOIN players p1 ON m.player1_id = p1.id
      LEFT JOIN players p2 ON m.player2_id = p2.id
      LEFT JOIN players w ON m.winner_id = w.id
      WHERE m.tournament_id = ?
      ORDER BY m.round, m.match_number
    `, [tournament_id]);

    if (result.length === 0) {
      return res.json([]);
    }

    const columns = result[0].columns;
    const values = result[0].values;
    
    const matches = values.map(row => {
      const match = {};
      columns.forEach((col, index) => {
        match[col] = row[index];
      });
      return match;
    });

    res.json(matches);
  } catch (error) {
    console.error('Error fetching matches:', error);
    res.status(500).json({ error: 'Chyba pÅ™i naÄÃ­tÃ¡nÃ­ zÃ¡pasÅ¯' });
  }
});

// DELETE reset playoffs - removes all playoff matches
app.delete('/api/tournaments/:id/playoffs', (req, res) => {
  try {
    const db = getDB();
    const tournament_id = parseInt(req.params.id);

    // Check tournament exists
    const tRes = db.exec('SELECT typ FROM tournaments WHERE id = ?', [tournament_id]);
    if (tRes.length === 0 || tRes[0].values.length === 0) {
      return res.status(404).json({ error: 'Turnaj nenalezen' });
    }

    // Delete all playoff matches (round >= 900)
    const countRes = db.exec('SELECT COUNT(*) FROM matches WHERE tournament_id = ? AND round >= 900', [tournament_id]);
    const count = countRes.length ? countRes[0].values[0][0] : 0;

    db.run('DELETE FROM matches WHERE tournament_id = ? AND round >= 900', [tournament_id]);
    saveDB();

    res.json({ message: 'Play-off byl resetovÃ¡n', deletedMatches: count });
  } catch (error) {
    console.error('Error resetting playoffs:', error);
    res.status(500).json({ error: 'Chyba pÅ™i resetovÃ¡nÃ­ play-off' });
  }
});

// POST generate playoffs for mixed tournaments (groups must be finished)
app.post('/api/tournaments/:id/playoffs', (req, res) => {
  try {
    const db = getDB();
    const tournament_id = parseInt(req.params.id);

    // Load tournament
    const tRes = db.exec('SELECT * FROM tournaments WHERE id = ?', [tournament_id]);
    if (tRes.length === 0 || tRes[0].values.length === 0) {
      return res.status(404).json({ error: 'Turnaj nenalezen' });
    }
    const t = {}; tRes[0].columns.forEach((c,i)=>{ t[c]=tRes[0].values[0][i]; });
    if (t.typ !== 'smiseny') {
      return res.status(400).json({ error: 'Play-off lze generovat pouze pro smÃ­Å¡enÃ½ turnaj' });
    }
    if (t.status !== 'probiha') {
      return res.status(400).json({ error: 'Play-off lze generovat pouze bÄ›hem probÃ­hajÃ­cÃ­ho turnaje' });
    }

    // Check if playoffs already exist
    const poRes = db.exec('SELECT COUNT(*) FROM matches WHERE tournament_id = ? AND round >= 900', [tournament_id]);
    const playoffCount = poRes.length ? poRes[0].values[0][0] : 0;
    if (playoffCount > 0) {
      return res.status(400).json({ error: 'Play-off jiÅ¾ byl vygenerovÃ¡n' });
    }

    // Ensure all group matches finished
    const unfinished = db.exec("SELECT COUNT(*) FROM matches WHERE tournament_id = ? AND round < 900 AND (status IS NULL OR status != 'ukonceny')", [tournament_id]);
    const unfinishedCount = unfinished.length ? unfinished[0].values[0][0] : 0;
    if (unfinishedCount > 0) {
      return res.status(400).json({ error: 'Nejprve dohrajte vÅ¡echny zÃ¡pasy ve skupinÃ¡ch' });
    }

    // Load group matches and compute standings per group
    const gMatchesRes = db.exec('SELECT * FROM matches WHERE tournament_id = ? AND round < 900', [tournament_id]);
    if (gMatchesRes.length === 0) {
      return res.status(400).json({ error: 'Nejsou k dispozici Å¾Ã¡dnÃ© zÃ¡pasy skupin' });
    }
    const mCols = gMatchesRes[0].columns;
    const groupMatches = gMatchesRes[0].values.map(v=>{ const m={}; mCols.forEach((c,i)=>m[c]=v[i]); return m; });

    // Group keys
    const groups = new Map();
    groupMatches.forEach(m => {
      const g = Math.floor(m.round / 100) || 1;
      if (!groups.has(g)) groups.set(g, []);
      groups.get(g).push(m);
    });

    const compute = (playerIds, matches) => {
      const table = new Map();
      playerIds.forEach(pid => table.set(pid, { player_id: pid, played:0, wins:0, losses:0, sets_won:0, sets_lost:0 }));
      matches.forEach(m => {
        if (!m.player1_id || !m.player2_id) return;
        const a = table.get(m.player1_id) || table.set(m.player1_id, { player_id: m.player1_id, played:0, wins:0, losses:0, sets_won:0, sets_lost:0 }).get(m.player1_id);
        const b = table.get(m.player2_id) || table.set(m.player2_id, { player_id: m.player2_id, played:0, wins:0, losses:0, sets_won:0, sets_lost:0 }).get(m.player2_id);
        a.played++; b.played++;
        a.sets_won += m.player1_score || 0; a.sets_lost += m.player2_score || 0;
        b.sets_won += m.player2_score || 0; b.sets_lost += m.player1_score || 0;
        if ((m.player1_score||0) > (m.player2_score||0)) { a.wins++; b.losses++; } else { b.wins++; a.losses++; }
      });
      const arr = Array.from(table.values());
      arr.forEach(r => r.sets_diff = (r.sets_won - r.sets_lost));
      arr.sort((a,b)=>{
        if (b.wins!==a.wins) return b.wins-a.wins;
        if (b.sets_diff!==a.sets_diff) return b.sets_diff-a.sets_diff;
        if (b.sets_won!==a.sets_won) return b.sets_won-a.sets_won;
        return a.player_id - b.player_id;
      });
      return arr;
    };

    // Build qualifiers: top 2 from each group
    const qualifiers = [];
    const sortedGroups = Array.from(groups.keys()).sort((a,b)=>a-b);
    sortedGroups.forEach(g => {
      const ms = groups.get(g);
      const ids = new Set();
      ms.forEach(m=>{ if (m.player1_id) ids.add(m.player1_id); if (m.player2_id) ids.add(m.player2_id); });
      const standings = compute(Array.from(ids), ms);
      if (standings.length > 0) qualifiers.push({ seedType:'winner', group:g, player_id: standings[0].player_id });
      if (standings.length > 1) qualifiers.push({ seedType:'runner', group:g, player_id: standings[1].player_id });
    });

    if (qualifiers.length < 2) {
      return res.status(400).json({ error: 'Nedostatek hrÃ¡ÄÅ¯ pro play-off' });
    }

    // Seed: winners first (by group order), then runners-up; then bracket seeding 1 vs last, 2 vs last-1
    const winners = qualifiers.filter(q=>q.seedType==='winner').map(q=>q.player_id);
    const runners = qualifiers.filter(q=>q.seedType==='runner').map(q=>q.player_id);
    const seeds = winners.concat(runners);

    const bracketSize = Math.pow(2, Math.ceil(Math.log2(seeds.length)));
    while (seeds.length < bracketSize) seeds.push(null);

    const firstRound = [];
    for (let i = 0; i < bracketSize/2; i++) {
      const p1 = seeds[i];
      const p2 = seeds[bracketSize - 1 - i];
      if (p1 !== null || p2 !== null) {
        firstRound.push({ player1_id: p1, player2_id: p2 });
      }
    }

    // Insert first playoff round (round 900)
    let matchNo = 1;
    firstRound.forEach(m => {
      // Only persist matches where both players exist; skip BYE pairs
      if (m.player1_id && m.player2_id) {
        db.run(`
          INSERT INTO matches (tournament_id, round, match_number, player1_id, player2_id, status)
          VALUES (?, ?, ?, ?, ?, 'nehrany')
        `, [tournament_id, 900, matchNo++, m.player1_id, m.player2_id]);
      }
    });

    const createdRes = db.exec('SELECT COUNT(*) FROM matches WHERE tournament_id = ? AND round = 900', [tournament_id]);
    const created = createdRes.length ? createdRes[0].values[0][0] : 0;

    saveDB();
    return res.json({ message: 'Play-off vygenerovÃ¡no', matchesCreated: created });
  } catch (error) {
    console.error('Error generating playoffs:', error);
    res.status(500).json({ error: 'Chyba pÅ™i generovÃ¡nÃ­ play-off' });
  }
});

// POST generate next playoff round
app.post('/api/tournaments/:id/playoffs/next-round', (req, res) => {
  try {
    const db = getDB();
    const tournament_id = parseInt(req.params.id);

    // Check tournament exists and is mixed
    const tRes = db.exec('SELECT * FROM tournaments WHERE id = ?', [tournament_id]);
    if (tRes.length === 0 || tRes[0].values.length === 0) {
      return res.status(404).json({ error: 'Turnaj nenalezen' });
    }
    const t = {}; tRes[0].columns.forEach((c,i)=>{ t[c]=tRes[0].values[0][i]; });
    if (t.typ !== 'smiseny') {
      return res.status(400).json({ error: 'DalÅ¡Ã­ kolo play-off lze generovat pouze pro smÃ­Å¡enÃ½ turnaj' });
    }
    if (t.status !== 'probiha') {
      return res.status(400).json({ error: 'Play-off lze generovat pouze bÄ›hem probÃ­hajÃ­cÃ­ho turnaje' });
    }

    // Find highest playoff round
    const roundsRes = db.exec('SELECT DISTINCT round FROM matches WHERE tournament_id = ? AND round >= 900 ORDER BY round DESC', [tournament_id]);
    if (roundsRes.length === 0 || roundsRes[0].values.length === 0) {
      return res.status(400).json({ error: 'Play-off nebylo jeÅ¡tÄ› vygenerovÃ¡no' });
    }
    const currentRound = roundsRes[0].values[0][0];

    // Check all matches in current round are finished
    const unfinishedRes = db.exec("SELECT COUNT(*) FROM matches WHERE tournament_id = ? AND round = ? AND (status IS NULL OR status != 'ukonceny')", [tournament_id, currentRound]);
    const unfinishedCount = unfinishedRes.length ? unfinishedRes[0].values[0][0] : 0;
    if (unfinishedCount > 0) {
      return res.status(400).json({ error: 'Nejprve dohrajte vÅ¡echny zÃ¡pasy aktuÃ¡lnÃ­ho kola play-off' });
    }

    // Check if next round already exists
    const nextRoundRes = db.exec('SELECT COUNT(*) FROM matches WHERE tournament_id = ? AND round = ?', [tournament_id, currentRound + 1]);
    const nextRoundCount = nextRoundRes.length ? nextRoundRes[0].values[0][0] : 0;
    if (nextRoundCount > 0) {
      return res.status(400).json({ error: 'DalÅ¡Ã­ kolo play-off jiÅ¾ bylo vygenerovÃ¡no' });
    }

    // Load current round matches with winners
    const matchesRes = db.exec('SELECT * FROM matches WHERE tournament_id = ? AND round = ? ORDER BY match_number', [tournament_id, currentRound]);
    if (matchesRes.length === 0) {
      return res.status(400).json({ error: 'Nenalezeny Å¾Ã¡dnÃ© zÃ¡pasy aktuÃ¡lnÃ­ho kola' });
    }
    const mCols = matchesRes[0].columns;
    const matches = matchesRes[0].values.map(v => { const m={}; mCols.forEach((c,i)=>m[c]=v[i]); return m; });

    // Collect winners in match order
    const winners = matches.map(m => m.winner_id).filter(w => w !== null);
    
    if (winners.length < 2) {
      return res.status(400).json({ error: 'Nedostatek vÃ­tÄ›zÅ¯ pro dalÅ¡Ã­ kolo' });
    }

    // Check if this is the final (only 1 match would be created)
    if (winners.length === 1) {
      return res.status(400).json({ error: 'Play-off je dokonÄeno, vÃ­tÄ›z byl urÄen' });
    }

    // Create next round matches by pairing winners
    const nextRound = currentRound + 1;
    let matchNo = 1;
    for (let i = 0; i < winners.length; i += 2) {
      if (i + 1 < winners.length) {
        db.run(`
          INSERT INTO matches (tournament_id, round, match_number, player1_id, player2_id, status)
          VALUES (?, ?, ?, ?, ?, 'nehrany')
        `, [tournament_id, nextRound, matchNo++, winners[i], winners[i + 1]]);
      }
    }

    const createdRes = db.exec('SELECT COUNT(*) FROM matches WHERE tournament_id = ? AND round = ?', [tournament_id, nextRound]);
    const created = createdRes.length ? createdRes[0].values[0][0] : 0;

    saveDB();
    return res.json({ message: 'DalÅ¡Ã­ kolo play-off vygenerovÃ¡no', matchesCreated: created, round: nextRound });
  } catch (error) {
    console.error('Error generating next playoff round:', error);
    res.status(500).json({ error: 'Chyba pÅ™i generovÃ¡nÃ­ dalÅ¡Ã­ho kola play-off' });
  }
});

// PUT update match result
app.put('/api/matches/:id/result', (req, res) => {
  try {
    const db = getDB();
    const matchId = parseInt(req.params.id);
    const { player1_score, player2_score } = req.body || {};

    // Validate presence
    if (player1_score === undefined || player2_score === undefined) {
      return res.status(400).json({ error: 'ChybÃ­ vÃ½sledek zÃ¡pasu' });
    }

    const s1 = parseInt(player1_score);
    const s2 = parseInt(player2_score);

    // Allowed results for BO5: 3:0, 3:1, 3:2, 2:3, 1:3, 0:3
    const allowed = (
      (s1 === 3 && [0,1,2].includes(s2)) ||
      (s2 === 3 && [0,1,2].includes(s1))
    );
    if (!allowed) {
      return res.status(400).json({ error: 'NeplatnÃ½ vÃ½sledek. PovolenÃ©: 3:0, 3:1, 3:2, 2:3, 1:3, 0:3' });
    }

    // Load match
    const matchResult = db.exec('SELECT * FROM matches WHERE id = ?', [matchId]);
    if (matchResult.length === 0 || matchResult[0].values.length === 0) {
      return res.status(404).json({ error: 'ZÃ¡pas nenalezen' });
    }

    const columns = matchResult[0].columns;
    const values = matchResult[0].values[0];
    const match = {};
    columns.forEach((col, index) => { match[col] = values[index]; });

    // Determine winner
    let winner_id = null;
    if (s1 > s2) winner_id = match.player1_id; else winner_id = match.player2_id;

    db.run(`
      UPDATE matches
      SET player1_score = ?, player2_score = ?, winner_id = ?, status = 'ukonceny'
      WHERE id = ?
    `, [s1, s2, winner_id, matchId]);

    saveDB();

    // AUTO-PROGRESSION: Check if we should generate next playoff round
    let autoGeneratedNextRound = false;
    if (match.round >= 900) {
      // This is a playoff match - check if tournament is mixed type
      const tRes = db.exec('SELECT typ FROM tournaments WHERE id = ?', [match.tournament_id]);
      if (tRes.length > 0 && tRes[0].values.length > 0) {
        const tournamentType = tRes[0].values[0][0];
        if (tournamentType === 'smiseny') {
          // Check if all matches in this playoff round are now finished
          const unfinishedRes = db.exec(
            "SELECT COUNT(*) FROM matches WHERE tournament_id = ? AND round = ? AND (status IS NULL OR status != 'ukonceny')",
            [match.tournament_id, match.round]
          );
          const unfinishedCount = unfinishedRes.length ? unfinishedRes[0].values[0][0] : 0;
          
          if (unfinishedCount === 0) {
            // All matches in this playoff round are finished - try to generate next round
            // First check if next round already exists
            const nextRoundRes = db.exec('SELECT COUNT(*) FROM matches WHERE tournament_id = ? AND round = ?', 
              [match.tournament_id, match.round + 1]);
            const nextRoundExists = nextRoundRes.length > 0 && nextRoundRes[0].values[0][0] > 0;
            
            if (!nextRoundExists) {
              // Load current round matches to get winners
              const matchesRes = db.exec('SELECT * FROM matches WHERE tournament_id = ? AND round = ? ORDER BY match_number', 
                [match.tournament_id, match.round]);
              if (matchesRes.length > 0) {
                const mCols = matchesRes[0].columns;
                const matches = matchesRes[0].values.map(v => { const m={}; mCols.forEach((c,i)=>m[c]=v[i]); return m; });
                const winners = matches.map(m => m.winner_id).filter(w => w !== null);
                
                // Only generate next round if we have at least 2 winners and this isn't the final
                if (winners.length >= 2) {
                  const nextRound = match.round + 1;
                  let matchNo = 1;
                  for (let i = 0; i < winners.length; i += 2) {
                    if (i + 1 < winners.length) {
                      db.run(`
                        INSERT INTO matches (tournament_id, round, match_number, player1_id, player2_id, status)
                        VALUES (?, ?, ?, ?, ?, 'nehrany')
                      `, [match.tournament_id, nextRound, matchNo++, winners[i], winners[i + 1]]);
                    }
                  }
                  saveDB();
                  autoGeneratedNextRound = true;
                }
              }
            }
          }
        }
      }
    }

    // Return updated match with names
    const updated = db.exec(`
      SELECT m.*, p1.jmeno as player1_name, p2.jmeno as player2_name, w.jmeno as winner_name
      FROM matches m
      LEFT JOIN players p1 ON m.player1_id = p1.id
      LEFT JOIN players p2 ON m.player2_id = p2.id
      LEFT JOIN players w ON m.winner_id = w.id
      WHERE m.id = ?
    `, [matchId]);

    const out = {};
    updated[0].columns.forEach((col, i) => { out[col] = updated[0].values[0][i]; });
    out.autoGeneratedNextRound = autoGeneratedNextRound;
    res.json(out);
  } catch (error) {
    console.error('Error updating match result:', error);
    res.status(500).json({ error: 'Chyba pÅ™i uklÃ¡dÃ¡nÃ­ vÃ½sledku zÃ¡pasu' });
  }
});

// PUT reset match result (clear score and winner)
app.put('/api/matches/:id/reset', (req, res) => {
  try {
    const db = getDB();
    const matchId = parseInt(req.params.id);

    // Ensure match exists
    const matchRes = db.exec('SELECT id FROM matches WHERE id = ?', [matchId]);
    if (matchRes.length === 0 || matchRes[0].values.length === 0) {
      return res.status(404).json({ error: 'ZÃ¡pas nenalezen' });
    }

    db.run(`
      UPDATE matches
      SET player1_score = NULL, player2_score = NULL, winner_id = NULL, status = 'nehrany'
      WHERE id = ?
    `, [matchId]);

    saveDB();

    const updated = db.exec(`
      SELECT m.*, p1.jmeno as player1_name, p2.jmeno as player2_name
      FROM matches m
      LEFT JOIN players p1 ON m.player1_id = p1.id
      LEFT JOIN players p2 ON m.player2_id = p2.id
      WHERE m.id = ?
    `, [matchId]);

    const out = {};
    updated[0].columns.forEach((col, i) => { out[col] = updated[0].values[0][i]; });
    res.json(out);
  } catch (error) {
    console.error('Error resetting match result:', error);
    res.status(500).json({ error: 'Chyba pÅ™i resetovÃ¡nÃ­ vÃ½sledku zÃ¡pasu' });
  }
});

// GET standings for a tournament
app.get('/api/tournaments/:id/standings', (req, res) => {
  try {
    const db = getDB();
    const tournament_id = parseInt(req.params.id);

    // Load tournament
    const tRes = db.exec('SELECT * FROM tournaments WHERE id = ?', [tournament_id]);
    if (tRes.length === 0 || tRes[0].values.length === 0) {
      return res.status(404).json({ error: 'Turnaj nenalezen' });
    }
    const t = {};
    tRes[0].columns.forEach((c,i)=>{ t[c]=tRes[0].values[0][i]; });

    // Load finished matches
    const matchesRes = db.exec(`
      SELECT m.* FROM matches m
      WHERE m.tournament_id = ? AND m.status = 'ukonceny'
    `, [tournament_id]);

    if (matchesRes.length === 0) {
      if (t.typ === 'pavouk') return res.json({ type: t.typ, standings: [] });
      return res.json({ type: t.typ, standings: [] });
    }

    const mCols = matchesRes[0].columns;
    const rows = matchesRes[0].values.map(v => {
      const m = {}; mCols.forEach((c,i)=>{ m[c]=v[i]; }); return m;
    });

    // Helper to compute standings for a set of players and matches
    const compute = (playersIds, matches) => {
      const table = new Map();
      playersIds.forEach(pid => {
        table.set(pid, { player_id: pid, played: 0, wins: 0, losses: 0, sets_won: 0, sets_lost: 0 });
      });
      matches.forEach(m => {
        if (!m.player1_id || !m.player2_id) return;
        const a = table.get(m.player1_id) || table.set(m.player1_id, { player_id: m.player1_id, played:0,wins:0,losses:0,sets_won:0,sets_lost:0}).get(m.player1_id);
        const b = table.get(m.player2_id) || table.set(m.player2_id, { player_id: m.player2_id, played:0,wins:0,losses:0,sets_won:0,sets_lost:0}).get(m.player2_id);
        a.played++; b.played++;
        a.sets_won += m.player1_score || 0; a.sets_lost += m.player2_score || 0;
        b.sets_won += m.player2_score || 0; b.sets_lost += m.player1_score || 0;
        if ((m.player1_score||0) > (m.player2_score||0)) { a.wins++; b.losses++; } else { b.wins++; a.losses++; }
      });
      const arr = Array.from(table.values());
      arr.forEach(r => r.sets_diff = (r.sets_won - r.sets_lost));
      // Attach names
      if (arr.length) {
        const ids = arr.map(r=>r.player_id).join(',');
        const namesRes = db.exec(`SELECT id, jmeno FROM players WHERE id IN (${ids})`);
        const nameMap = new Map();
        if (namesRes.length) {
          namesRes[0].values.forEach(v => nameMap.set(v[0], v[1]));
        }
        arr.forEach(r => r.jmeno = nameMap.get(r.player_id) || '');
      }
      arr.sort((a,b)=>{
        if (b.wins!==a.wins) return b.wins-a.wins;
        if (b.sets_diff!==a.sets_diff) return b.sets_diff-a.sets_diff;
        if (b.sets_won!==a.sets_won) return b.sets_won-a.sets_won;
        return a.jmeno.localeCompare(b.jmeno, 'cs');
      });
      // Add position
      arr.forEach((r,i)=>r.poradi=i+1);
      return arr;
    };

    if (t.typ === 'pavouk') {
      return res.json({ type: t.typ, standings: [] });
    }

    if (t.typ === 'skupina') {
      // All players in tournament
      const pRes = db.exec('SELECT id FROM players WHERE tournament_id = ?', [tournament_id]);
      const pIds = pRes.length ? pRes[0].values.map(v=>v[0]) : [];
      const standings = compute(pIds, rows);
      return res.json({ type: t.typ, standings });
    }

    // smiseny â€“ compute per group based on round number prefix (100s)
    const groups = new Map();
    rows.filter(m=>m.round < 900).forEach(m => {
      const group = Math.floor(m.round / 100) || 1;
      if (!groups.has(group)) groups.set(group, []);
      groups.get(group).push(m);
    });

    const result = [];
    groups.forEach((gMatches, groupNo) => {
      const ids = new Set();
      gMatches.forEach(m=>{ if (m.player1_id) ids.add(m.player1_id); if (m.player2_id) ids.add(m.player2_id); });
      const standings = compute(Array.from(ids), gMatches);
      result.push({ group: groupNo, standings });
    });

    result.sort((a,b)=>a.group-b.group);
    return res.json({ type: t.typ, groups: result });
  } catch (error) {
    console.error('Error computing standings:', error);
    res.status(500).json({ error: 'Chyba pÅ™i vÃ½poÄtu tabulky' });
  }
});

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'OK', message: 'Server bÄ›Å¾Ã­' });
});

app.listen(PORT, () => {
  console.log(`ðŸš€ Server bÄ›Å¾Ã­ na http://localhost:${PORT}`);
  console.log(`ðŸ“Š API endpoint: http://localhost:${PORT}/api/tournaments`);
});
